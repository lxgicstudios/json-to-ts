export interface GeneratorOptions {
  rootName?: string;
  useType?: boolean;
  optional?: boolean;
  exportTypes?: boolean;
}

type JsonValue = string | number | boolean | null | JsonValue[] | { [key: string]: JsonValue };

/**
 * Convert a string to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())
    .replace(/^./, (chr) => chr.toUpperCase())
    .replace(/[^a-zA-Z0-9]/g, '');
}

/**
 * Convert a string to camelCase
 */
function toCamelCase(str: string): string {
  const pascal = toPascalCase(str);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

/**
 * Detect the TypeScript type of a JSON value
 */
function detectType(value: JsonValue, key: string, interfaces: Map<string, string[]>): string {
  if (value === null) {
    return 'null';
  }

  if (Array.isArray(value)) {
    if (value.length === 0) {
      return 'unknown[]';
    }

    // Check if all items have the same type
    const itemTypes = new Set(value.map(item => detectType(item, key, interfaces)));
    
    if (itemTypes.size === 1) {
      const [itemType] = itemTypes;
      return `${itemType}[]`;
    }

    // Mixed array
    return `(${Array.from(itemTypes).join(' | ')})[]`;
  }

  if (typeof value === 'object') {
    const interfaceName = toPascalCase(key);
    generateInterface(value, interfaceName, interfaces);
    return interfaceName;
  }

  if (typeof value === 'string') {
    // Check for specific patterns
    if (/^\d{4}-\d{2}-\d{2}(T\d{2}:\d{2}:\d{2})?/.test(value)) {
      return 'string'; // ISO date
    }
    if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
      return 'string'; // UUID
    }
    return 'string';
  }

  if (typeof value === 'number') {
    return Number.isInteger(value) ? 'number' : 'number';
  }

  if (typeof value === 'boolean') {
    return 'boolean';
  }

  return 'unknown';
}

/**
 * Generate interface for an object
 */
function generateInterface(
  obj: { [key: string]: JsonValue },
  name: string,
  interfaces: Map<string, string[]>
): void {
  if (interfaces.has(name)) {
    return;
  }

  const lines: string[] = [];
  
  for (const [key, value] of Object.entries(obj)) {
    const propName = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(key) ? key : `'${key}'`;
    const propType = detectType(value, key, interfaces);
    lines.push(`  ${propName}: ${propType};`);
  }

  interfaces.set(name, lines);
}

/**
 * Generate TypeScript from JSON
 */
export function jsonToTypeScript(
  json: JsonValue,
  options: GeneratorOptions = {}
): string {
  const {
    rootName = 'Root',
    useType = false,
    optional = false,
    exportTypes = true
  } = options;

  const interfaces = new Map<string, string[]>();
  
  // Handle array at root
  if (Array.isArray(json)) {
    if (json.length > 0 && typeof json[0] === 'object' && json[0] !== null) {
      generateInterface(json[0] as { [key: string]: JsonValue }, rootName, interfaces);
    }
  } else if (typeof json === 'object' && json !== null) {
    generateInterface(json as { [key: string]: JsonValue }, rootName, interfaces);
  } else {
    return `${exportTypes ? 'export ' : ''}type ${rootName} = ${typeof json};`;
  }

  // Generate output
  const output: string[] = [
    '/**',
    ' * Auto-generated TypeScript types',
    ' * Generated by @lxgicstudios/json-to-ts',
    ' */',
    ''
  ];

  const keyword = useType ? 'type' : 'interface';
  const prefix = exportTypes ? 'export ' : '';

  // Output interfaces in reverse order (nested first)
  const names = Array.from(interfaces.keys()).reverse();

  for (const name of names) {
    const lines = interfaces.get(name)!;
    
    if (useType) {
      output.push(`${prefix}type ${name} = {`);
    } else {
      output.push(`${prefix}interface ${name} {`);
    }

    for (let line of lines) {
      if (optional) {
        line = line.replace(/: /, '?: ');
      }
      output.push(line);
    }

    if (useType) {
      output.push('};');
    } else {
      output.push('}');
    }
    output.push('');
  }

  // Add array type if root was array
  if (Array.isArray(json)) {
    output.push(`${prefix}type ${rootName}Array = ${rootName}[];`);
    output.push('');
  }

  return output.join('\n');
}

/**
 * Parse JSON string and generate TypeScript
 */
export function parseAndGenerate(
  jsonString: string,
  options: GeneratorOptions = {}
): string {
  let parsed: JsonValue;
  
  try {
    parsed = JSON.parse(jsonString);
  } catch (e) {
    throw new Error('Invalid JSON: ' + (e instanceof Error ? e.message : 'Parse error'));
  }

  return jsonToTypeScript(parsed, options);
}

/**
 * Fetch JSON from URL and generate TypeScript
 */
export async function fetchAndGenerate(
  url: string,
  options: GeneratorOptions = {}
): Promise<string> {
  const response = await fetch(url);
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const json = await response.json();
  return jsonToTypeScript(json, options);
}
